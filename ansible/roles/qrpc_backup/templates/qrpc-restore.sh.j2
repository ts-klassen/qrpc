#!/bin/bash
#
# Managed by Ansible - wraps duplicity restores for /opt/qrpc.

set -Eeuo pipefail

usage() {
  cat <<'EOF'
Usage: qrpc-restore [options] <destination>

Restore the /opt/qrpc duplicity backup into <destination>. The destination is
mandatory unless you only request informational commands.

Options:
  --time <spec>            Restore data as of <spec> (duplicity time syntax)
  --file <path>            Restore a single file relative to /opt/qrpc
  --force                  Allow overwriting existing files (passes --force)
  --list-files             Show files available in the most recent backup
  --collection-status      Show duplicity collection status
  --dry-run                Print duplicity commands without running them
  -h, --help               Show this help text

Examples:
  qrpc-restore /tmp/qrpc-restore
  qrpc-restore --time "2024-12-01T00:00:00" /tmp/qrpc-restore
  qrpc-restore --file etc/qrpc.config ./qrpc.config
  qrpc-restore --list-files
EOF
}

log() {
  printf '%s %s\n' "$(date --iso-8601=seconds)" "$*"
}

fatal() {
  log "$*"
  exit 1
}

on_error() {
  log "Restore failed (line $1)"
}
trap 'on_error ${LINENO}' ERR

TARGET="{{ qrpc_backup_target_url }}"
DUPLICITY_BIN="{{ qrpc_backup_duplicity_path }}"
ARCHIVE_DIR="{{ qrpc_backup_archive_dir }}"
TEMP_DIR="{{ qrpc_backup_temp_dir }}"
ENV_FILE="{{ qrpc_backup_env_file }}"
RESTORE_PATH_FLAG="--file-to-restore"

BASE_ARGS=( "--name" "{{ qrpc_backup_name }}" "--archive-dir" "$ARCHIVE_DIR" )

EXTRA_ARGS=()
{% for opt in qrpc_backup_extra_options %}
EXTRA_ARGS+=( "{{ opt }}" )
{% endfor %}

S3_ARGS=()
{% if qrpc_backup_s3_endpoint | length > 0 %}
S3_ARGS+=( "--s3-endpoint-url" "{{ qrpc_backup_s3_endpoint | trim('/') }}" )
{% endif %}

COMMON_ARGS=( "${BASE_ARGS[@]}" "${S3_ARGS[@]}" "${EXTRA_ARGS[@]}" )

if [[ ! -x "$DUPLICITY_BIN" ]]; then
  fatal "Duplicity binary not executable at $DUPLICITY_BIN"
fi

if [[ -z "${TARGET:-}" ]]; then
  fatal "Backup target URL is empty"
fi

umask 027
mkdir -p "$ARCHIVE_DIR" "$TEMP_DIR"

if [[ -f "$ENV_FILE" ]]; then
  # shellcheck disable=SC1090
  set -a
  source "$ENV_FILE"
  set +a
else
  log "Environment file $ENV_FILE is missing; proceeding without additional environment overrides."
fi

if [[ "{{ qrpc_backup_disable_s3_if_match | ternary('1', '0') }}" == "1" ]]; then
  log "Disabling duplicity S3 If-Match enforcement via QRPC shim"
  export QRPC_DISABLE_S3_IFMATCH=1
  if [[ -z "${PYTHONPATH:-}" ]]; then
    export PYTHONPATH="{{ qrpc_backup_python_patch_dir }}"
  else
    export PYTHONPATH="{{ qrpc_backup_python_patch_dir }}:${PYTHONPATH}"
  fi
fi

if DUPLICITY_VERSION_RAW="$("$DUPLICITY_BIN" --version 2>/dev/null | head -n1)"; then
  if [[ "$DUPLICITY_VERSION_RAW" =~ ([0-9]+)\. ]]; then
    DUPLICITY_MAJOR="${BASH_REMATCH[1]}"
    if (( DUPLICITY_MAJOR >= 2 )); then
      RESTORE_PATH_FLAG="--path-to-restore"
    fi
  fi
else
  log "Warning: unable to detect duplicity version; defaulting to legacy restore flag."
fi

DRY_RUN=0
FORCE_RESTORE=0
LIST_FILES=0
COLLECTION_STATUS=0
TIME_SPEC=""
FILE_PATH=""
DESTINATION=""

add_destination() {
  local value="$1"
  if [[ -z "$value" ]]; then
    fatal "Destination value is empty"
  fi
  if [[ -n "$DESTINATION" ]]; then
    fatal "Only one destination path can be provided"
  fi
  DESTINATION="$value"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --time)
      [[ $# -ge 2 ]] || fatal "--time requires an argument"
      TIME_SPEC="$2"
      shift 2
      ;;
    --file)
      [[ $# -ge 2 ]] || fatal "--file requires an argument"
      FILE_PATH="$2"
      shift 2
      ;;
    --force)
      FORCE_RESTORE=1
      shift
      ;;
    --list-files)
      LIST_FILES=1
      shift
      ;;
    --collection-status)
      COLLECTION_STATUS=1
      shift
      ;;
    --dry-run)
      DRY_RUN=1
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    --)
      shift
      while [[ $# -gt 0 ]]; do
        add_destination "$1"
        shift
      done
      break
      ;;
    -*)
      fatal "Unknown option: $1"
      ;;
    *)
      add_destination "$1"
      shift
      ;;
  esac
done

if (( LIST_FILES == 0 && COLLECTION_STATUS == 0 )) && [[ -z "$DESTINATION" ]]; then
  usage
  exit 1
fi

run_cmd() {
  if (( DRY_RUN )); then
    printf 'DRY-RUN:'
    for arg in "$@"; do
      printf ' %q' "$arg"
    done
    printf '\n'
    return 0
  fi
  "$@"
}

prepare_destination() {
  local path="$1"
  if [[ -z "$path" ]]; then
    fatal "Destination path is empty"
  fi

  if [[ -z "$FILE_PATH" ]]; then
    if [[ -d "$path" ]]; then
      if (( FORCE_RESTORE == 0 )); then
        if [[ -n "$(ls -A "$path")" ]]; then
          fatal "Destination directory $path exists and is not empty; re-run with --force to overwrite."
        fi
      fi
    elif [[ -e "$path" ]]; then
      if (( FORCE_RESTORE == 0 )); then
        fatal "Destination path $path already exists; re-run with --force to overwrite."
      fi
    elif (( DRY_RUN == 0 )); then
      mkdir -p "$path"
    fi
  else
    local parent
    parent="$(dirname "$path")"
    if (( DRY_RUN == 0 )); then
      mkdir -p "$parent"
    fi
    if [[ -e "$path" ]] && (( FORCE_RESTORE == 0 )); then
      fatal "Destination file $path already exists; re-run with --force to overwrite."
    fi
  fi
}

if (( COLLECTION_STATUS )); then
  log "Showing duplicity collection status for ${TARGET}"
  run_cmd "$DUPLICITY_BIN" "${COMMON_ARGS[@]}" collection-status "$TARGET"
fi

if (( LIST_FILES )); then
  log "Listing files stored in duplicity target ${TARGET}"
  run_cmd "$DUPLICITY_BIN" "${COMMON_ARGS[@]}" list-current-files "$TARGET"
fi

if [[ -n "$DESTINATION" ]]; then
  prepare_destination "$DESTINATION"
  log "Restoring duplicity backup from ${TARGET} into ${DESTINATION}"

  restore_cmd=( "$DUPLICITY_BIN" "${COMMON_ARGS[@]}" "--tempdir" "$TEMP_DIR" )

  if [[ -n "$TIME_SPEC" ]]; then
    restore_cmd+=( "--time" "$TIME_SPEC" )
  fi

  if [[ -n "$FILE_PATH" ]]; then
    restore_cmd+=( "$RESTORE_PATH_FLAG" "$FILE_PATH" )
  fi

  if (( FORCE_RESTORE )); then
    restore_cmd+=( "--force" )
  fi

  restore_cmd+=( "$TARGET" "$DESTINATION" )

  run_cmd "${restore_cmd[@]}"
  log "qrpc duplicity restore complete"
fi
