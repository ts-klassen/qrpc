-module(qrpc_error).
-include_lib("qrpc/include/qrpc.hrl").

-export([
        error/2
      , macro_QRPC_ERROR/2
      , rethrow/1
      , get/2
      , get/3
      , lookup/2
    ]).

-export_type([
        error/0
      , metadata/0
      , payload/0
      , partial_payload/0
    ]).

-define(ERROR_TYPE, #{
        qrpc_map_calls := #{ module := ?MODULE, type := error, pos := head }
      , metadata := _
      , payload := _
      , rethrow := _
    }).
-type error() :: #{
        qrpc_map_calls := #{ module := ?MODULE, type := error, pos := head }
      , metadata := metadata()
      , payload := payload()
      , rethrow := {error | exit | throw, term(), erlang:stacktrace()}
    }.

-define(METADATA, #{
        qrpc_map_calls := #{ module := ?MODULE, type := metadata, pos := head }
      , module := _
      , function_name := _
      , function_arity := _
      , file := _
      , line := _
      , otp_release := _
      , macro := _
      , macro_version := _
      , app_vsn := _
      , server_name := _
      , uuid := _
    }).
-type metadata() :: #{
        qrpc_map_calls := #{ module := ?MODULE, type := metadata, pos := head }
      , module := module()
      , function_name := atom()
      , function_arity := non_neg_integer()
      , file := klsn:binstr()
      , line := pos_integer()
      , otp_release := klsn:binstr()
      , macro := 'QRPC_ERROR'
      , macro_version := 1
      , app_vsn := klsn:optnl({atom(), klsn:optnl(klsn:binstr())})
      , server_name := klsn:optnl(klsn:binstr())
      , uuid := klsn:binstr() % auto generated by macro
    }.

-define(PAYLOAD, #{
        qrpc_map_calls := #{ module := ?MODULE, type := payload, pos := head }
      , id := [_|_]
      , fault_source := _
      , is_known := _
      , is_retryable := _
      , should_auto_retry := _
    }).
-type payload() :: #{
        qrpc_map_calls := #{ module := ?MODULE, type := payload, pos := head }
      , id := [atom(), ...]
      , fault_source := client | server | external | unknown % default unknown
      , message := klsn:binstr() % default <<"Unknown error.">>
      , message_ja := klsn:binstr() % default <<"不明なエラー。"/utf8>>
      , is_known := boolean() % default false
      , is_retryable := boolean() % default false
      , should_auto_retry := boolean() % default false
      , retry_count => non_neg_integer() % 0 if first error.
      , retry_after => non_neg_integer() % sec from now. ex. 60
      , detail => term % you can put whatever here.
      , class => error | exit | throw
      , reason => term()
      , stacktrace => erlang:stacktrace()
      , args => [term()]
      , version => integer()
    }.

-type partial_payload() :: #{
        id := [atom(), ...]
      , fault_source => client | server | external | unknown % default unknown
      , message => klsn:binstr() % default <<"Unknown error.">>
      , message_ja => klsn:binstr() % default <<"不明なエラー。"/utf8>>
      , is_known => boolean() % default false
      , is_retryable => boolean() % default false
      , should_auto_retry => boolean() % default false
      , retry_count => non_neg_integer() % 0 if first error.
      , retry_after => non_neg_integer() % sec from now. ex. 60
      , detail => term() % you can put whatever here.
      , class => error | exit | throw
      , reason => term()
      , stacktrace => erlang:stacktrace()
      , args => [term()]
      , version => integer()
    }.


-spec macro_QRPC_ERROR(
        {module(), atom(), non_neg_integer(), string(), pos_integer(), string()}
      , partial_payload()
    ) -> no_return().
macro_QRPC_ERROR(Tuple, Payload) ->
    {Module, FunName, FunArity, File, Line, OTP} = Tuple,
    qrpc_error:error(
        #{
            qrpc_map_calls => #{ module => ?MODULE, type => metadata, pos => head }
          , module => Module
          , function_name => FunName
          , function_arity => FunArity
          , file => klsn_binstr:from_any(File)
          , line => Line
          , otp_release => klsn_binstr:from_any(OTP)
          , macro => 'QRPC_ERROR'
          , macro_version => 1
          , app_vsn => begin case application:get_application(Module) of
                {ok, App} ->
                    {value, case application:get_key(App, vsn) of
                                {ok, Vsn} ->
                                    {value, klsn_binstr:from_any(Vsn)};
                                undefined ->
                                    none
                            end};
                undefined ->
                    none
            end end
          , server_name => qrpc_conf:lookup(server_name)
          , uuid => klsn_binstr:uuid()
        }
      , (maps:merge(#{
            fault_source => unknown
          , message => <<"Unknown error.">>
          , message_ja => <<"不明なエラー。"/utf8>>
          , is_known => false
          , is_retryable => false
          , should_auto_retry => false
        }, Payload))#{
            qrpc_map_calls => #{ module => ?MODULE, type => payload, pos => head }
        }
    ).


-spec error(metadata(), payload()) -> no_return().
error(Metadata=?METADATA, Payload=?PAYLOAD) ->
    Reason = #{
        qrpc_map_calls => #{ module => ?MODULE, type => error, pos => head }
      , metadata => Metadata
      , payload => Payload
    },
    try
        case Payload of
            #{args := Args} when is_list(Args) ->
                erlang:error(Reason, Args);
            _ ->
                erlang:error(Reason)
        end
    catch
        error:Error=#{qrpc_map_calls := #{ module := ?MODULE, type := error, pos := head }}:Stack ->
            erlang:raise(error, Error#{rethrow => {error, Error, Stack}}, Stack)
    end.

-spec rethrow(error()) -> no_return().
rethrow(QrpcError=?ERROR_TYPE) ->
    #{rethrow := {error, _Error, Stack}} = QrpcError,
    erlang:raise(error, QrpcError, Stack).

-spec get(error(), klsn_map:path()) -> term().
get(QrpcError=?ERROR_TYPE, Path) ->
    case lookup(QrpcError, Path) of
        {value, Value} ->
            Value;
        none ->
            ?QRPC_ERROR(#{
                id => [qrpc, error, get, not_found]
              , fault_source => server
              , message => <<"Missing backend specified field.">>
              , message_ja => <<"指定したフィールドが存在しませんでした。"/utf8>>
              , detail => #{
                    path => Path
                  , qrpc_error => QrpcError
                }
              , is_known => true
              , is_retryable => false
              , version => 1
            })
    end.

-spec get(error(), klsn_map:path(), term()) -> term().
get(QrpcError=?ERROR_TYPE, Path, Default) ->
    case lookup(QrpcError, Path) of
        {value, Value} ->
            Value;
        none ->
            Default
    end.

-spec lookup(error(), klsn_map:path()) -> term().
lookup(QrpcError=?ERROR_TYPE, Path) ->
    klsn_map:lookup(Path, QrpcError).

